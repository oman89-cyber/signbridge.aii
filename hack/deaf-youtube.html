<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Deaf Mode — Voice → YouTube Avatar (Timed Segments)</title>
<style>
  :root { --bg:#000; --card:#0b0b0b; --text:#eaeaea; --muted:#9aa0a6; }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;position:relative;overflow-x:hidden}
  
  /* Background stars and gradient */
  body::before {
    content: "";
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
      radial-gradient(circle at 20% 30%, rgba(100, 150, 200, 0.05) 0%, transparent 40%),
      radial-gradient(circle at 80% 70%, rgba(150, 180, 220, 0.04) 0%, transparent 35%),
      linear-gradient(to bottom, #000000 0%, #0a0a0a 40%, #0d0d0d 70%, #000000 100%);
    z-index: -3;
  }
  
  /* Cracked glass layer */
  .crack-layer {
    position: fixed;
    inset: 0;
    z-index: -1;
    pointer-events: none;
    overflow: hidden;
    opacity: 0.7;
  }
  
  .crack-line {
    position: absolute;
    background: linear-gradient(90deg, 
      transparent 0%,
      rgba(255, 0, 0, 0.6) 10%,
      rgba(0, 255, 0, 0.6) 30%,
      rgba(0, 0, 255, 0.6) 50%,
      rgba(255, 0, 255, 0.6) 70%,
      rgba(255, 255, 0, 0.6) 90%,
      transparent 100%
    );
    transform-origin: center;
    box-shadow: 
      0 0 8px 2px rgba(255, 0, 0, 0.5),
      0 0 16px 4px rgba(0, 255, 0, 0.4),
      0 0 24px 6px rgba(0, 0, 255, 0.3),
      0 0 32px 8px rgba(255, 0, 255, 0.2);
    animation: crackGlow 2s ease-in-out infinite alternate;
    filter: blur(1px);
  }
  
  @keyframes crackGlow {
    0% { opacity: 0.5; filter: blur(1px) brightness(1); }
    50% { opacity: 0.8; filter: blur(1.5px) brightness(1.3); }
    100% { opacity: 0.6; filter: blur(1px) brightness(1.1); }
  }
  
  .wrap{max-width:1100px;margin:28px auto;padding:0 16px;display:grid;gap:16px;grid-template-columns:1.3fr 1fr;position:relative;z-index:1}
  @media (max-width:900px){.wrap{grid-template-columns:1fr}}
  .card{background:rgba(11,11,11,0.8);border:1px solid #1a1a1a;border-radius:16px;padding:16px;backdrop-filter:blur(5px)}
  .player{position:relative;aspect-ratio:16/9;border-radius:12px;overflow:hidden;background:#000}
  #ytPlayer{width:100%;height:100%}
  .pill{margin-top:10px;font-size:14px;opacity:.9}
  .live{min-height:24px;color:var(--muted)}
  .final{min-height:28px;font-weight:700}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;align-items:center}
  button{background:#111;border:1px solid #2a2a2a;color:#fff;border-radius:10px;padding:10px 14px;cursor:pointer}
  button:hover{border-color:#3a3a3a}
  .status{margin-left:auto;font-size:12px;color:var(--muted);padding:10px}
  .hint{font-size:12px;color:#bbb;margin-top:8px}
</style>
</head>
<body>
  <!-- Cracked glass layer with RGB glow -->
  <div class="crack-layer" id="crackLayer" aria-hidden="true"></div>
  
  <main class="wrap">
    <!-- Left: Avatar (YouTube) -->
    <section class="card">
      <h2 style="margin:0 0 8px">Sign Avatar (YouTube – Timed)</h2>
      <div class="player"><div id="ytPlayer" aria-label="Sign avatar video"></div></div>
      <div id="matchPill" class="pill">say one of the mapped lines…</div>
      <div class="hint">Tap **Start Mic** once, then speak a sentence → exact video segment auto-plays (muted). Use Unmute for sound.</div>
      <div class="controls" style="margin-top:8px">
        <button id="unmuteBtn" title="Enable sound">Unmute</button>
        <button id="muteBtn"   title="Mute sound">Mute</button>
      </div>
    </section>

    <!-- Right: Transcript + Controls -->
    <aside class="card">
      <h2 style="margin:0 0 8px">Live Transcript</h2>
      <div id="interim" class="live" aria-live="polite"></div>
      <div id="final" class="final" aria-live="assertive"></div>
      <div class="controls">
        <button id="startBtn">Start Mic</button>
        <button id="pauseBtn">Pause</button>
        <button id="resumeBtn">Resume</button>
        <button id="clearBtn">Clear</button>
        <div id="micStatus" class="status">status: idle</div>
      </div>
    </aside>
  </main>

  <!-- YouTube IFrame API -->
  <script src="https://www.youtube.com/iframe_api"></script>
  <script>
    // ==== EXACT PHRASE → YOUTUBE ID + START/END (seconds) ====
    const YT_MAP = {
      // Shorts IDs from your links + your precise time windows
      "how are you?":          { videoId: "au6XKphzods", startSeconds: 27, endSeconds: 30 },
      "what are you doing?":   { videoId: "z3SfbYvdSh4" },                 // full short
      "what is your name?":    { videoId: "4ZdR1B2cO44", startSeconds: 1,  endSeconds: 5  },
      "nice to meet you.":     { videoId: "TYC8mCQ9E14", startSeconds: 19, endSeconds: 32 },
      "please wait a moment.": { videoId: "FyEmINVbOxU" },                  // full video
      "can i help you?":       { videoId: "iWm9RmVrt3E" }                   // full video
    };

    // Optional aliases so minor variations still match
    const ALIASES = {
      "how are you": "how are you?",
      "what are you doing": "what are you doing?",
      "what is your name": "what is your name?",
      "please wait a moment": "please wait a moment.",
      "can you help me?": "can i help you?",
      "can you help me": "can i help you?"
    };

    // ====== UI refs ======
    const interimEl = document.getElementById('interim');
    const finalEl   = document.getElementById('final');
    const pillEl    = document.getElementById('matchPill');
    const statusEl  = document.getElementById('micStatus');
    const startBtn  = document.getElementById('startBtn');
    const pauseBtn  = document.getElementById('pauseBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const clearBtn  = document.getElementById('clearBtn');
    const unmuteBtn = document.getElementById('unmuteBtn');
    const muteBtn   = document.getElementById('muteBtn');

    // ====== YouTube Player with segment guard ======
    let player, ytReady = false, segmentTimer = null, currentEnd = null;

    function onYouTubeIframeAPIReady(){
      player = new YT.Player('ytPlayer', {
        width:'640', height:'360',
        videoId: Object.values(YT_MAP)[0].videoId, // warm any video
        playerVars: {
          controls: 0, autoplay: 0, rel: 0, modestbranding: 1,
          playsinline: 1, iv_load_policy: 3
        },
        events: {
          onReady: () => { ytReady = true; try{ player.mute(); }catch(e){} },
          onStateChange: onYTStateChange
        }
      });
    }
    window.onYouTubeIframeAPIReady = onYouTubeIframeAPIReady;

    function clearSegmentTimer(){
      if(segmentTimer){ clearInterval(segmentTimer); segmentTimer = null; }
      currentEnd = null;
    }

    function onYTStateChange(e){
      // Hard-stop at our endSeconds (YouTube sometimes overruns a little)
      if(e.data === YT.PlayerState.PLAYING && typeof currentEnd === "number"){
        clearSegmentTimer();
        segmentTimer = setInterval(() => {
          try{
            const t = player.getCurrentTime?.();
            if(typeof t === "number" && t >= currentEnd - 0.05){
              player.pauseVideo();
              clearSegmentTimer();
            }
          }catch(_){}
        }, 50);
      } else if(e.data === YT.PlayerState.PAUSED || e.data === YT.PlayerState.ENDED){
        clearSegmentTimer();
      }
    }

    function playForPhrase(phrase){
      if(!ytReady || !player) return;
      const cfg = YT_MAP[phrase];
      if(!cfg){ pillEl.textContent = "no mapped video"; return; }

      const start = cfg.startSeconds ?? 0;
      const end   = (typeof cfg.endSeconds === "number" && cfg.endSeconds > start) ? cfg.endSeconds : undefined;
      currentEnd  = end ?? null;

      // Cue the chosen segment, then play (muted) — no frame click needed
      player.cueVideoById({
        videoId: cfg.videoId,
        startSeconds: start,
        endSeconds: end
      });
      try { player.playVideo(); } catch(e) {}
      pillEl.textContent = `showing: “${phrase}”` + (end ? ` ( ${start}s → ${end}s )` : "");
    }

    // ====== Un/Mute controls (optional) ======
    unmuteBtn.addEventListener('click', () => { try{ player.unMute(); }catch(e){} });
    muteBtn.addEventListener('click',   () => { try{ player.mute();   }catch(e){} });

    // ====== Speech Recognition ======
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recog, listening = false;

    function setMicState(s){ statusEl.textContent = 'status: ' + s; }

    function normalize(s=""){
      return s.toLowerCase()
        .replace(/[“”]/g,'"').replace(/[’]/g,"'")
        .replace(/[^a-z0-9?' .]/g,"")
        .replace(/\s+/g," ").trim();
    }

    function resolvePhrase(text){
      const t = normalize(text);
      if (ALIASES[t]) return ALIASES[t];
      for(const key of Object.keys(YT_MAP)){
        if (normalize(key) === t) return key;
        if (t === normalize(key).replace(/[?.]+$/,"")) return key;
      }
      return null;
    }

    function initSR(){
      if(!SR){ setMicState("speech API unsupported"); return; }
      recog = new SR();
      recog.lang = "en-IN";   // adjust if needed
      recog.continuous = true;
      recog.interimResults = true;

      recog.onstart = () => { listening = true; setMicState("listening"); };
      recog.onend   = () => { listening = false; setMicState("paused"); };
      recog.onerror = (e)  => { setMicState("error: "+e.error); };

      recog.onresult = (ev) => {
        let interim = "", finalText = "";
        for(let i=ev.resultIndex; i<ev.results.length; i++){
          const r = ev.results[i];
          if(r.isFinal) finalText += r[0].transcript;
          else interim += r[0].transcript;
        }
        if(interim) interimEl.textContent = interim;
        if(finalText){
          interimEl.textContent = "";
          finalEl.textContent = finalText;
          const match = resolvePhrase(finalText);
          if(match) playForPhrase(match);
          else pillEl.textContent = "no preset sign for this sentence yet";
        }
      };
    }

    // ====== Controls ======
    startBtn.addEventListener('click', () => {
      // One user gesture required for mic + autoplay; videos then auto-play muted
      try{ player && player.mute(); }catch(e){}
      if(!recog) initSR();
      try{ recog.start(); }catch(e){}
    });
    pauseBtn.addEventListener('click',  () => { if(recog && listening) try{ recog.stop(); }catch(e){} });
    resumeBtn.addEventListener('click', () => { if(recog && !listening) try{ recog.start(); }catch(e){} });
    clearBtn.addEventListener('click',  () => {
      interimEl.textContent=""; finalEl.textContent=""; pillEl.textContent="say one of the mapped lines…";
      clearSegmentTimer();
      try{ player.pauseVideo(); }catch(e){}
    });

    // Warm the player after load for snappy start
    document.addEventListener('DOMContentLoaded', () => {
      setMicState("idle");
      const any = Object.values(YT_MAP)[0];
      const warm = setInterval(() => {
        if(ytReady && player && any){
          try{ player.cueVideoById({ videoId: any.videoId, startSeconds: any.startSeconds||0 }); }catch(e){}
          clearInterval(warm);
        }
      }, 150);
      
      // Initialize cracked glass effect
      createCrackedGlass();
    });
    
    // Cracked glass effect function
    function createCrackedGlass() {
      const crackLayer = document.getElementById('crackLayer');
      if (!crackLayer) return;

      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;
      
      const crackOrigins = [
        { x: screenWidth * 0.15, y: screenHeight * 0.3 },
        { x: screenWidth * 0.25, y: screenHeight * 0.7 },
        { x: screenWidth * 0.5, y: screenHeight * 0.5 },
        { x: screenWidth * 0.75, y: screenHeight * 0.4 },
        { x: screenWidth * 0.85, y: screenHeight * 0.65 }
      ];

      crackOrigins.forEach((origin) => {
        const numCracks = 8 + Math.floor(Math.random() * 7);
        
        for (let i = 0; i < numCracks; i++) {
          const crack = document.createElement('div');
          crack.className = 'crack-line';
          const angle = (360 / numCracks) * i + (Math.random() - 0.5) * 45;
          const length = 100 + Math.random() * 300;
          const width = 1 + Math.random() * 2;
          
          crack.style.left = origin.x + 'px';
          crack.style.top = origin.y + 'px';
          crack.style.width = length + 'px';
          crack.style.height = width + 'px';
          crack.style.transform = `rotate(${angle}deg)`;
          crack.style.animationDelay = (Math.random() * 2) + 's';
          
          crackLayer.appendChild(crack);
        }
        
        const branchCracks = 5 + Math.floor(Math.random() * 5);
        for (let i = 0; i < branchCracks; i++) {
          const crack = document.createElement('div');
          crack.className = 'crack-line';
          
          const offsetAngle = Math.random() * 360;
          const offsetDistance = 50 + Math.random() * 150;
          const branchX = origin.x + Math.cos(offsetAngle * Math.PI / 180) * offsetDistance;
          const branchY = origin.y + Math.sin(offsetAngle * Math.PI / 180) * offsetDistance;
          
          const angle = Math.random() * 360;
          const length = 50 + Math.random() * 150;
          const width = 0.5 + Math.random();
          
          crack.style.left = branchX + 'px';
          crack.style.top = branchY + 'px';
          crack.style.width = length + 'px';
          crack.style.height = width + 'px';
          crack.style.transform = `rotate(${angle}deg)`;
          crack.style.animationDelay = (Math.random() * 2) + 's';
          crack.style.opacity = 0.6;
          
          crackLayer.appendChild(crack);
        }
      });
    }
  </script>
</body>
</html>
